---
title: "Predicting reintroduction sites using habitat selection in an endangered mesopredator"
author: "Kathryn Macpherson, Belinda Wilson, Shoshana Rapley"
date: "January 12, 2024"
output: 
  html_document:
    toc: true
    number_sections: true
    top_depth: 3
    toc_float:
      collapsed: true
    theme: cerulean
    highlight: pygments
editor_options:
  chunk_output_type: console
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), 'tutorial.html')) })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=FALSE)
```

# **Background**

Reintroductions are a key strategy for reversing biodiversity loss (Sheean *et al*. 2012) and restoring ecological function (Lipsey & Child 2007). Their success can often be attributed to habitat suitability at the recipient site (Bennett *et al*. 2012), since it drives resource (i.e., food, shelter, protection) and mate availability (Su *et al*. 2021). It is important to confirm the habitat suitability of a recipient site, often through monitoring the movement and habitat selection of founders (individuals released for a reintroduction, Bennett *et al*. 2012).

We reintroduced eastern quolls (*Dasyurus viverrinus*) in a series of trials over three consecutive years (2016–2018) into a conservation-fenced sanctuary as part of the [Mulligans Flat-Goorooyarroo Woodland Experiment](https://www.coexistenceconservationlab.org/mulligans-flat-goorooyarroo-woodland-experiment). Throughout these trials, we radiotracked founders to reveal >200 diurnal dens.

Here we explore the habitat selection of reintroduced eastern quolls to predict suitable habitat for future translocations, using species distribution models (SDMs).

# **Setup**

First, we manually installed the [pacman Package Management Tool](https://cran.r-project.org/web/packages/pacman/index.html), which enables us to install and load subsequent packages in a condensed and efficient way.

We also manually installed `Rtools` (after having [downloaded the most up-to-date version from CRAN](https://cran.r-project.org/bin/windows/Rtools/)), and the `slga` (soils) package from GitHub.

These manual installations only need to be done once, upon first running the project.

```{r, eval=FALSE}
# Manually install pacman package
install.packages(pacman)

# Manually install Rtools package
installr::install.Rtools(check=TRUE, check_r_update=TRUE, GUI=TRUE)

# Manually install slga package
devtools::install_github("obrl-soil/slga")
```

```{r}
# Install and load required packages
pacman::p_load(beepr, data.table, devtools, dplyr, elevatr, ggmap, ggplot2, ggpubr, ggsn, ggspatial, freqtables, installr, janitor, lme4, lubridate, MuMIn, ncdf4, plotrix, plotROC, raster, rasterVis, readxl, reshape2, rgdal, rgl, rJava, rstudioapi, scales, SDMtune, sf, slga, st, stringr, terra, tidyr, tidyterra, tidyverse, viridis, zeallot)
```

We also set the working directory to where this R markdown is saved using the `rstudioapi` package.

```{r}
# Set working directory to where your Rmarkdown is saved
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

# **Data preparation**

Here we read in our eastern quoll den assessment data, and compare each of our *intrinsic* den covariates with what is available throughout MFWS. These are:

  1.  **Den type** (open, hole, grass, log, pipe, drain, or culvert)
  2.  **Den cover** (ground, rocky outcrop, log, stump, fallen tree roots, living tree, dead tree, termite mound, pipe, drain, culvert, or building)
  3.  **Den substrate** (natural, experiment, or artificial)
  4.  **Number of entrances** (1, 2, or ≥3)
  5.  **Plot type** (open, or kangaroo exclusion zone)
  6.  **Habitat** (open grassland, Eucalypt forest, or Eucalypt woodland)
  7.  **Activity** (active, inactive, or could not locate)

## Import

```{r}
# Assign raw data filename to an object
raw_data <- "data.xlsx"

# Read in data
data <- read_excel(raw_data, sheet="dens") %>%
  clean_names() %>%
  # Convert numeric dates to date format
  mutate(date = as.Date(date, origin="1899-12-30"), 
         entrances = as.factor(entrances_holes)) %>%
  dplyr::select(den_id, sector, "den_type"=type, 
                "den_cover"=under, "den_substrate"='in', 
                entrances_holes, plot_type, habitat, activity, 
                easting, northing, latitude, longitude) %>%
  subset(sector!="Outside")
```

Calculate how many dens were first found in each study year.

```{r}
years <- read_excel(raw_data, sheet="visits") %>%
  clean_names() %>%
  mutate(year=year(as.Date(date_tracked))) %>%
  group_by(eqd_code) %>%
  summarise(min(year)) %>%
  clean_names() %>%
  group_by(min_year) %>%
  count()
```

As expected, the number of dens first identified decreased throughout the years (119  in 2016, 79 in 2017, and 33 in 2018). 

### Den map

Here we generate a map of the den sites coloured in order of first use: oldest dens are purple, middle dens are green, and newest dens are yellow (ranging February 2016–November 2018).

You will need to [generate your own API key](https://developers.google.com/maps/documentation/javascript/get-api-key) to fetch the basemap from Google.

```{r,echo=FALSE, eval=FALSE}
# Read in MFWS fence shapefile for plotting
mfws <- readOGR(dsn="shapefiles/mfws_fence.shp", verbose=FALSE) %>%
  spTransform(CRS("+proj=utm +zone=55 +datum=WGS84")) %>%
  fortify(verbose=FALSE) %>% #transforms from from sp to df
  mutate(lat=as.numeric(lat + 10000000), 
         long=as.numeric(long))

# Use Google API to fetch a base map
#ggmap::register_google(key="[enter API key here]")
sat <- get_map(location=c(lat=-35.16580, lon=149.16454),
               zoom=14, source="google", maptype="satellite", crop=TRUE)

# Display the map
ggmap(sat)

# Read in MFWS fence shapefile for plotting
mf_outline <- readOGR(dsn="shapefiles/mfws_fence.shp", verbose=FALSE) %>%
  spTransform("EPSG:4326") %>%
  fortify(verbose=FALSE) #transforms from from sp to df

# Read in MFWS fence shapefile for plotting
mf_tracks <- readOGR(dsn="shapefiles/MFWS_tracks.shp", verbose=FALSE) %>%
  spTransform("EPSG:4326") %>%
  fortify(verbose=FALSE) #transforms from from sp to df

# Create a map
den_map_sat <- ggmap(sat) +
  geom_path(mf_outline, mapping=aes(x=long, y=lat, group=group),
            col="white", size=1) +
  geom_path(mf_tracks, mapping=aes(x=long, y=lat, group=group),
            col="white", size=0.5) +
  geom_point(data, mapping=aes(x=longitude, y=latitude, 
                               col=den_id), size=2, alpha=0.8) +
  ggsn::scalebar(y.min=-35.153, x.min=149.145, 
                 y.max=-35.182, x.max=149.190,
                 dist=500, height=3, dist_unit="m",
                 box.color="white", st.color="white",
                 st.size=3, anchor=c(y=-35.175, x=149.182),
                 st.dist=0.04, transform=TRUE) +
  theme(panel.grid.major=element_blank(),
        panel.background=element_rect(fill="white"),
        plot.margin=unit(c(0, 0, 0, 0), "cm"),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none", 
        legend.key=element_blank()) +
  scale_colour_viridis(discrete=T, option="D", begin=0, end=1) +
  xlab("") + ylab("")

# Display the plot
print(den_map_sat)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(den_map_sat, filename="figures/den satellite map.jpeg", 
       width=200, height=125, units="mm")
```

# **Intrinsic den covariates**

## Den type

  a) Plots

```{r}
# Transfer from wide to long format, and calculate percent for each level
long <- data %>%
  group_by(den_type) %>%
  summarise(percent = 100/nrow(data)*length(den_type), 
            n = length(den_type)) %>%
  na.omit() %>% mutate(den_type = factor(den_type, 
                                         levels=c("Natural", 
                                                  "Experiment", 
                                                  "Artificial")))

# Create histogram plot
den_type_hist <- ggplot(long, aes(x=den_type, y=percent, fill=den_type)) +
  geom_col() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Den type") + ylab("Percentage (%)") +
  # Viridis scale options are A–E
  scale_fill_viridis(discrete=T, option="D", begin=0.9, end=0.2) +
  scale_y_continuous(limits=c(0, 100), breaks=seq(0, 100, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))


# Histogram for publication
den_type_hist_pub <- ggplot(long, aes(x=den_type, y=percent, fill=den_type)) +
  geom_col() +
  annotate("text", x=3.5, y=90, label = parse(text = "bold('a')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Den type") + ylab("Percentage (%)") +
  # Viridis scale options are A–E
  scale_fill_viridis(discrete=T, option="D", begin=0.9, end=0.2) +
  scale_y_continuous(limits=c(0, 90), breaks=seq(0, 90, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Display the plot
print(den_type_hist_pub)

# Subset to those records with valid den substrates
plot_data <- subset(data, den_type!="NA")

# Create map plot
den_type_map <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat, group=group), 
            col="grey15") +
  geom_point(plot_data, mapping=aes(x=easting, y=northing, 
                                    col=den_type), alpha=0.8) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.70, 0.25),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"),
        legend.key = element_blank()) +
  scale_colour_manual(values=viridis(length(unique(data$den_type)), 
                                     begin=0.9, end=0.2), name="Den type",
                      breaks=c('Natural', 'Experiment', 'Artificial')) +
  xlab("") + ylab("")

# Combine histogram and map
den_type_plots <- ggarrange(den_type_hist, den_type_map, 
                            ncol=2, nrow=1, widths=c(3,3))

# Display the plot
print(den_type_plots)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(den_type_plots, 
       filename="figures/den type histogram and map.jpeg", 
       width=200, height=75, units="mm")

# Export the plot to a jpeg file
ggsave(den_type_hist_pub, 
       filename="figures/den type histogram publication.jpeg", 
       width=150, height=75, units="mm")
```

  b) Models

```{r}
# Chi-square test
den_type_mod <- data %>%
  subset(den_type!="N/A") %>%
  freq_table(den_type) %>%
  freq_test() %>%
  select(c(1:3, 5, 7, 12:14))
```

## Den cover

  a) Plots

```{r}
# Transfer from wide to long format, and calculate percent for each level
long <- data %>%
  group_by(den_cover) %>%
  summarise(percent = 100/nrow(data)*length(den_cover), 
            n = length(den_cover)) %>% 
  na.omit()

# Create histogram plot
den_cover_hist <- ggplot(long, aes(x=den_cover, y=percent, fill=den_cover)) +
  geom_col() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        legend.position = "none",
        axis.text.x = element_text(angle=-45, vjust=0.5, hjust=0.2),
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey"),
  plot.margin = unit(c(0.5, 0.75, 0, 0.2), "cm")) +
  xlab("Den cover") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 50), breaks=seq(0, 100, 20)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))


# Histogram for publication
den_cover_hist_pub <- ggplot(long, aes(x=den_cover, y=percent, fill=den_cover)) +
  geom_col() +
  annotate("text", x=10.5, y=50, label = parse(text = "bold('c')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
        legend.position = "none",
        axis.text.x = element_text(angle=-45, vjust=0.5, hjust=0.2),
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Den cover") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 50), breaks=seq(0, 50, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Display the plot
print(den_cover_hist_pub)

# Subset to those records with valid den covers
plot_data <- subset(data, den_cover!="NA")

# Create map plot
den_cover_map <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat, group=group), col="grey15") +
  geom_point(plot_data, mapping=aes(x=easting, y=northing, 
                                    col=den_cover), alpha=0.8) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.85, 0.25),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"),
        legend.key = element_blank()) +
  scale_colour_manual(values=viridis(length(unique(data$den_cover)), 
                                     begin=1, end=0), name="Den cover") + 
  guides(colour=guide_legend(ncol=2)) +
  xlab("") + ylab("")

# Combine histogram and map into single plot
den_cover_plots <- ggarrange(den_cover_hist, den_cover_map, 
                            ncol=2, nrow=1, widths=c(3,3))

# Display the plot
print(den_cover_plots)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(den_cover_plots, 
       filename="figures/den cover histogram and map.jpeg", 
       width=275, height=125, units="mm")

# Export the plot to a jpeg file
ggsave(den_cover_hist_pub, 
       filename="figures/den cover histogram publication.jpeg", 
       width=150, height=75, units="mm")
```

  b) Models

```{r}
# Chi-square test
den_cover_mod <- data %>%
  subset(den_cover!="N/A") %>%
  freq_table(den_cover) %>%
  freq_test() %>%
  select(c(1:3, 5, 7, 12:14))
```

## Den substrate

  a) Plots

```{r}
# Transfer from wide to long format, and calculate percent for each level
long <- data %>%
  group_by(den_substrate) %>%
  summarise(percent = 100/nrow(data)*length(den_substrate), 
            n = length(den_substrate)) %>%
  na.omit()

# Create histogram plot
den_substrate_hist <- ggplot(long, aes(x=den_substrate, y=percent, 
                                       fill=den_substrate)) +
  geom_col() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Den substrate") + ylab("Percentage (%)") +
  # Options include magma, inferno, plasma, viridis, turbo
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 90), breaks=seq(0, 100, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Histogram for publication
den_substrate_hist_pub <- ggplot(long, aes(x=den_substrate, y=percent, 
                                       fill=den_substrate)) +
  geom_col() +
  annotate("text", x=5.5, y=90, label = parse(text = "bold('b')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Den substrate") + ylab("Percentage (%)") +
  # Options include magma, inferno, plasma, viridis, turbo
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 90), breaks=seq(0, 90, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Display the plot
print(den_substrate_hist_pub)

# Subset to those records with valid den substrates
plot_data <- subset(data, den_substrate!="NA")

# Create map plot
den_substrate_map <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat, group=group), 
            col="grey15") +
  geom_point(plot_data, mapping=aes(x=easting, y=northing, 
                                    col=den_substrate), alpha=0.8) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.70, 0.25),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"),
        legend.key = element_blank()) +
  scale_colour_manual(values=viridis(length(unique(data$den_substrate)), 
                                     begin=1, end=0), name="Den substrate") +
  xlab("") + ylab("")

# Combine histogram and map into single plot
den_substrate_plots <- ggarrange(den_substrate_hist, 
                                 den_substrate_map, 
                                 ncol=2, nrow=1, widths=c(3,2))

# Display the plot
print(den_substrate_plots)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(den_substrate_plots, 
       filename="figures/den substrate histogram and map.jpeg", 
       width=250, height=125, units="mm")

# Export the plot to a jpeg file
ggsave(den_substrate_hist_pub, 
       filename="figures/den substrate histogram publication.jpeg", 
       width=150, height=75, units="mm")
```

  b) Models

```{r}
# Chi-square test
den_substrate_mod <- data %>%
  subset(den_substrate!="N/A") %>%
  freq_table(den_substrate) %>%
  freq_test() %>%
  select(c(1:3, 5, 7, 12:14))
```

## Number of entrances

```{r}
# Use ifelse to define entrance hole values
data_2 <- data %>%
  mutate(entrances = ifelse(entrances_holes==1, 1,
                     ifelse(entrances_holes==2, 2,
                     ifelse(entrances_holes=="≥3", "≥3", NA)))) %>%
  drop_na(entrances) %>%
  mutate(entrances = factor(entrances, levels=c("1", "2", "≥3")))
```

  a) Plots

```{r}
# Transfer from wide to long format, and calculate percent for each level
long <- data_2 %>%
  group_by(entrances) %>%
  summarise(percent = 100/nrow(data)*length(entrances), 
            n = length(entrances)) %>%
  na.omit()

# Create histogram plot
entrances_hist <- ggplot(long, aes(x=entrances, y=percent, 
                                       fill=entrances)) +
  geom_col() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Number of entrances") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.9, end=0.2) +
  scale_y_continuous(limits=c(0, 100), breaks=seq(0, 100, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Histogram for publication
entrances_hist_pub <- ggplot(long, aes(x=entrances, y=percent, 
                                       fill=entrances)) +
  geom_col() +
  annotate("text", x=3.5, y=80, label = parse(text = "bold('d')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Number of entrances") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.9, end=0.2) +
  scale_y_continuous(limits=c(0, 80), breaks=seq(0, 80, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Display the plot
print(entrances_hist_pub)

# Create map plot
entrances_map <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat, group=group), 
            col="grey15") +
  geom_point(data_2, mapping=aes(x=easting, y=northing, 
                                    col=entrances)) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.75, 0.25), 
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"),
        legend.key = element_blank()) +
  scale_colour_manual(values=viridis(length(unique(data_2$entrances)), 
                                     begin=0.9, end=0.2), 
                                     name="Number of entrances") +
                                     xlab("") + ylab("")

# Combine histogram and map into single plot
entrances_plots <- ggarrange(entrances_hist, 
                                 entrances_map, 
                                 ncol=2, nrow=1, widths=c(3,2))

# Display the plot
print(entrances_plots)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(entrances_plots, 
       filename="figures/entrances histogram and map.jpeg", 
       width=250, height=125, units="mm")

# Export the plot to a jpeg file
ggsave(entrances_hist_pub, 
       filename="figures/entrances histogram publication.jpeg", 
       width=150, height=75, units="mm")
```

  b) Models

```{r}
# Chi-square test
entrances_mod <- data %>%
  subset(entrances_holes!="N/A") %>%
  freq_table(entrances_holes) %>%
  freq_test() %>%
  select(c(1:3, 5, 7, 12:14))
```

## Plot type

### Plots

```{r}
# Transfer from wide to long format, and calculate percent for each level
long <- data %>%
  group_by(plot_type) %>%
  summarise(percent = 100/nrow(data)*length(plot_type), 
            n = length(plot_type)) %>%
  na.omit() %>% mutate(plot_type = factor(plot_type, levels=c("Open", "Kangaroo exclosure", "Bettong exclosure")))

# Create histogram plot
plot_type_hist <- ggplot(long, aes(x=plot_type, y=percent, 
                                       fill=plot_type)) +
  geom_col() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Plot type") + ylab("Percentage (%)") +
  # Options include magma, inferno, plasma, viridis, turbo
  scale_fill_viridis(discrete=T, option="D", begin=0.9, end=0.1) +
  scale_y_continuous(limits=c(0, 100), breaks=seq(0, 100, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Histogram for publication
plot_type_hist_pub <- ggplot(long, aes(x=plot_type, y=percent, 
                                       fill=plot_type)) +
  geom_col() + 
  annotate("text", x=3.5, y=90, label = parse(text = "bold('b')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Plot type") + ylab("Percentage (%)") +
  # Options include magma, inferno, plasma, viridis, turbo
  scale_fill_viridis(discrete=T, option="D", begin=0.9, end=0.1) +
  scale_y_continuous(limits=c(0, 100), breaks=seq(0, 100, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Display the plot
print(plot_type_hist_pub)

# Subset to those records with valid plot types
plot_data <- subset(data, plot_type!="NA")

# Create map plot
plot_type_map <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat, group=group), 
            col="grey15") +
  geom_point(plot_data, mapping=aes(x=easting, y=northing, 
                                    col=plot_type)) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.75, 0.25),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"),
        legend.key = element_blank()) +
  scale_colour_manual(values=viridis(length(unique(data$plot_type)), 
                                     begin=0.9, end=0.1), name="Plot type", 
                      breaks=c('Open', 'Kangaroo exclosure', 
                               'Bettong exclosure')) + xlab("") + ylab("")

# Combine histogram and map into single plot
plot_type_plots <- ggarrange(plot_type_hist, 
                                 plot_type_map, 
                                 ncol=2, nrow=1, widths=c(3,2))

# Display the plot
print(plot_type_plots)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(plot_type_plots, 
       filename="figures/plot type histogram and map.jpeg", 
       width=250, height=125, units="mm")

# Export the plot to a jpeg file
ggsave(plot_type_hist_pub, 
       filename="figures/plot type histogram publication.jpeg", 
       width=150, height=75, units="mm")
```

### Models

```{r}
# Chi-square test
plot_type_mod <- data %>%
  subset(plot_type!="N/A") %>%
  freq_table(plot_type) %>%
  freq_test() %>%
  select(c(1:3, 5, 7, 12:14))
```

### Adjust for availability within MFWS
  
```{r}
# Read in MFWS fence shapefile
mfws <- st_read("shapefiles/mfws_fence.shp")

# Reproject and prepare shapefile
mfws <- mfws %>%
  st_set_crs(st_crs(mfws)) %>%
  st_transform("EPSG:32755") %>% 
  clean_names() %>%
  mutate(plot="open") %>%
  # Since the roo layer only includes three column, we select them here
  select(id, geometry, plot)

# Read in MFWS kangaroo exclusion zone shapefile using sf
kan <- st_read("shapefiles/MFGO_kangaroo_exclosures_polygons.shp")

# Reproject and prepare shapefile
kan <- kan %>%
  st_set_crs(st_crs(kan)) %>%
  st_transform("EPSG:32755") %>% 
  clean_names() %>%
  mutate(plot="kangaroo", 
         id=row_number()) %>%
  # Remove exclosures in the adjacent reserve
  filter(id <6) %>%
  # Mutate id so it has prefix
  mutate(id=paste0("K", row_number()))

# Read in MFWS kangaroo exclusion zone shapefile using sf
bet <- st_read("shapefiles/MFWS_bettong_exclosures_polygons.shp") 

# Reproject and prepare shapefile
bet <- bet %>%
  st_set_crs(st_crs(bet)) %>%
  st_transform("EPSG:32755") %>% 
  clean_names() %>%
  # Since the roo layer only includes three column, we select them here
  select(id, geometry) %>%
  # Mutate id so it has prefix
  mutate(id=paste0("B", row_number())) %>%
  # Assign bettong plots inside kangaroo plots as another category
  mutate(id = ifelse(id == "B1", "KB1", 
              ifelse(id == "B6", "KB6", 
              ifelse(id == "B8", "KB8", 
              ifelse(id == "B9", "KB9",
              ifelse(id == "B10", "KB10", 
              ifelse(id == "B12", "KB12", id))))))) %>%
  # Assign zone type to these plots
  mutate(plot = ifelse(str_starts(id, "^B"), "bettong", "both"))
  
# Plot the plot types
ggplot() + 
  geom_sf(data=mfws_clip, aes(fill=plot)) + 
  geom_sf_text(data=mfws_clip, aes(label=plot)) +

  geom_sf(data=kan, aes(fill=id)) + 
  geom_sf_text(data=kan, aes(label=id)) +
  geom_sf(data=bet, aes(fill=id)) + 
  geom_sf_text(data=bet, aes(label=id)) +
  #coord_sf(expand=FALSE, xlim=c(extent(mfws)[1]+100, 
  #                             extent(mfws)[2]+100), 
  #                       ylim=c(extent(mfws)[3]+100, 
  #                              extent(mfws)[4]+100)) +
  theme_minimal() + 
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank())

# Crop MFWS polygon by the shape of kan and bet layers
mfws_clip <- st_difference(mfws, st_union(kan, bet)) %>%
  select(id=id.1, plot=plot.1, geometry)

# Combine kangaroo and bettong layers and calculate area
plots <- rbind(kan, bet) %>%
  # Calculate area of each geometry (or polygon)
  mutate(area_km2=as.numeric(st_area(geometry))/1e6)

plots_sum <- plots %>%
  as.data.frame() %>% 
  group_by(plot) %>%
  summarise(area_km2=sum(area_km2)) %>%
  select(plot, area_km2)

# Calculate the open plot area
plots_sum <- plots_sum %>%
  add_row(plot="open", area_km2=mfws_area_minus_aquatic-
            sum(plots$area_km2))

# Read in den coordinates data and prepare for plotting
den <- read_excel("data.xlsx", sheet="dens") %>% 
  clean_names() %>% 
  mutate(easting=as.numeric(easting), 
         northing=as.numeric(northing))

# Convert to spatial points dataframe
den_sp <- SpatialPointsDataFrame( 
  data.frame(den$easting, den$northing), den,
  proj4string=CRS("EPSG:32755")) %>% 
  st_as_sf()

# Join den coordinates and plots layer
den_zone <- st_join(den_sp, plots, join=st_intersects) %>%
  st_drop_geometry() %>%
  as.data.frame() %>%
  mutate(plot = ifelse(is.na(plot), "open", plot)) %>%
  # Remove dens outside MFWS
  filter(sector != "Outside", 
         !is.na(sector))

# Extract exclosure zone for each den coordinate and calculate frequencies
den_zone_adj <- den_zone %>%
  group_by(plot) %>% 
  count() %>% 
  # Since only one den occurs in both, but is included in the kangaroo plot
  # count, we exclude it
  filter(plot != "both") %>%
  # Adjusted by frequency of dens
  mutate(den_freq=n) %>%
  select(-n) %>%
  mutate(den_perc=(den_freq/sum(den_zone_adj$den_freq))*100) %>%
  # Remove dens outside MFWS
  filter(!is.na(plot))

# Assign MFWS minus aquatic area value
mfws_area_minus_aquatic <- sum(mfws_group$area_km2)-mfws_group$area_km2[1]

# Assign correct number of dens (223)
dens_n <- length(unique(den_zone$den))

# Adjust frequencies and percentages to account for exclosure zone availability
den_zone_plot <- den_zone_adj %>%
  # Join with df to get area_km2 column
  left_join(plots, by="plot") %>%
  group_by(plot) %>% 
  summarize(plot = max(plot), den_freq = max(den_freq), 
             den_perc = max(den_perc), area_km2 = sum(area_km2)) %>% 
  mutate(area_km2 = ifelse(plot == "open", 
                       # Calculate open area by subtracting other plot types
                       mfws_area_minus_aquatic-
                         (sum(area_km2, na.rm=TRUE)), area_km2)) %>%
  # Calculate frequency of dens adjusted by available area 
  mutate(den_freq_adj=(den_freq/area_km2)*
                         mfws_area_minus_aquatic/
                            nrow(den_zone_adj)) %>%
  # Redistributing so the number of dens is 223
  mutate(den_freq_adj=den_freq_adj/sum(den_freq_adj)*dens_n) %>%
  # Calculate percentage of dens adjusted by available area
  mutate(den_perc_adj=(den_freq_adj/sum(den_zone_plot$den_freq_adj))*100, 
         plot=factor(plot, levels = c("open", "kangaroo", "bettong"), 
                           labels = c("Open", "Kangaroo", "Bettong")))

# Display chi-square test for unequal distribution of dens
# after having been adjusted for available area 
den_zone %>%
  # Remove any dens that were in zone NA (i.e., outside MFWS)
  filter(!is.na(plot), 
        plot != "both") %>%
  freq_table(plot) %>%
  mutate(n=den_zone_plot$den_freq_adj, 
         percent=den_zone_plot$den_perc_adj) %>%
  freq_test() %>%
  # Select the statistics we're interested in
  select(plot=cat, n, percent, t_crit, 
         chi2_pearson, df, p=p_chi2_pearson)
```


 Bar plot
 
```{r}
# Plot raw den percentages per habitat type
zone_raw_barplot <- ggplot(data=den_zone_plot, 
  aes(x= plot, y=den_perc, fill=plot)) +
  geom_col() +
  annotate("text", x=3.5, y=90, label = parse(text = "bold('a')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"),
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0.2) +
  scale_y_continuous(limits=c(0, 90), breaks=seq(0, 90, 10)) 

# Display the plot
print(zone_raw_barplot)

# Plot adjusted den percentages per habitat type
zone_adj_barplot <- ggplot(data=den_zone_plot, 
  aes(x= plot, y=den_perc_adj, fill=plot)) +
  geom_col() +
  annotate("text", x=3.5, y=60, label = parse(text = "bold('b')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"),
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Percentage adjusted for availability (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0.2) +
  scale_y_continuous(limits=c(0, 60), breaks=seq(0, 60, 10)) 

# Display the plot
print(zone_adj_barplot)

# Combine the plots
zone_barplots <- ggarrange(zone_raw_barplot, zone_adj_barplot, ncol= 2, nrow= 1, 
                                   widths= c(1,1), heights = c(1,1)) %>%
  annotate_figure(bottom=text_grob("Exclosure zone", hjust=0.5, vjust=0))


# Display the combined plot
print(zone_barplots)
```

```{r, echo=FALSE, eval=FALSE}
ggsave(zone_barplots, 
       filename="figures/exclosure zone barplots.jpeg", 
       width=225, height=100, units="mm")
```

## Habitat

### Plots

```{r}
# Transfer from wide to long format, and calculate percent for each level
long <- plot_data %>%
  group_by(habitat) %>%
  summarise(percent = 100/nrow(plot_data)*length(habitat), 
            n = length(habitat))

# Create histogram plot
habitat_hist <- ggplot(long, aes(x=habitat, y=percent, fill=habitat)) +
  geom_col() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Habitat type") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 100), breaks=seq(0, 100, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Histogram for publication
habitat_hist_pub <- ggplot(long, aes(x=habitat, y=percent, fill=habitat)) +
  geom_col() +
  annotate("text", x=4.5, y=60, label = parse(text = "bold('a')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
        legend.position = "none",
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("Habitat type") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 60), breaks=seq(0, 60, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Display the plot
print(habitat_hist_pub)

# Subset to those records with valid habitat types
plot_data <- subset(data, habitat!="NA")

# Create map plot
habitat_type_map <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat, group=group), col="grey15") +
  geom_point(plot_data, mapping=aes(x=easting, y=northing, 
                                    col=habitat), alpha=0.8) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.70, 0.25),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"),
        legend.key = element_blank()) +
  scale_colour_manual(values=viridis(length(unique(data$habitat)), 
                                     begin=1, end=0), name="Habitat type") +
  xlab("") + ylab("")

# Combine histogram and map into single plot
habitat_type_plots <- ggarrange(habitat_hist, habitat_type_map, 
                                ncol=2, nrow=1, widths=c(3,3))

# Display the plot
print(habitat_type_plots)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(habitat_type_plots, 
       filename="figures/habitat type histogram and map.jpeg", 
       width=250, height=100, units="mm")

# Export the plot to a jpeg file
ggsave(habitat_hist_pub, 
       filename="figures/habitat type histogram publication.jpeg", 
       width=150, height=75, units="mm")
```

### Models

```{r}
# Chi-square test
habitat_type_mod <- data %>%
  subset(habitat!="N/A") %>%
  freq_table(habitat) %>%
  freq_test() %>%
  select(c(1:3, 5, 7, 12:14))
```

### Adjust for availability within MFWS

Map of NVIS habitat types (as per Wilson *et al*. *in review*).

```{r}
# Read in MFWS NVIS groups using sf
nvis <- st_read("shapefiles/mfws_nvis_vegetation_groups.shp") %>%
  st_transform("EPSG:4326") %>% 
  clean_names() %>% 
  mutate(mfws_name=factor(mfws_name, 
                          levels=c("Grassland", "Eucalypt forest", 
                                   "Eucalypt woodland", "Regrowth", 
                                   "Aquatic")))

# Map plot
nvis_mfws <- ggplot() + 
  geom_sf(st_zm(nvis), mapping=aes(fill=mfws_name), 
          col="grey30", lwd=0.5, alpha=0.8) + 
  annotation_scale(style="ticks", tick_height=0.5,
                   width_hint=0.3, 
                   pad_x=unit(1.55, "cm"),
                   pad_y=unit(0, "cm")) +
  #annotate(geom="text", y=-35.157, x=149.186, label="b)", fontface="bold", size=6)
  theme(axis.line.x = element_blank(),
        axis.line.y = element_blank(),
        legend.position = c(0.75, 0.15),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        plot.margin = unit(c(0, 0, 1, 0), "cm"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        panel.border = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.length = unit(0, "pt"),
        plot.title = element_text(hjust=0.5),
        text = element_text(colour="black"),
        axis.text.y = element_blank(),
        axis.text.x = element_blank()) +
  scale_fill_manual(values=viridis(5, begin=0.9, end=0.1)) +
  labs(fill="MFWS habitat", x=NULL, y=NULL) 
print(nvis_mfws)
```

```{r}
# Read in den coordinates data and prepare for plotting
den <- read_excel("data.xlsx", sheet="dens") %>% 
  clean_names() %>% 
  #na.omit() %>%
  mutate(easting=as.numeric(easting), 
         northing=as.numeric(northing), 
         date=as.POSIXct(date), 
         day=as.numeric(yday(date)))

# Convert to spatial points dataframe
den_sp <- SpatialPointsDataFrame( 
  data.frame(den$easting, den$northing), den,
  proj4string=CRS("EPSG:32755")) %>% 
  st_as_sf()

# Read in NVIS layer
nvis <- st_read("shapefiles/mfws_nvis_vegetation_groups.shp", quiet=TRUE) %>%
  st_transform("EPSG:32755")

# Join den coordinates and NVIS layer
den_nvis <- st_join(den_sp, nvis, join=st_intersects) %>%
  rename(mfws_habitat=MFWS_NAME) %>% 
  st_drop_geometry()

# Read in NVIS layer (warnings okay)
nvis_shp <- readOGR(dsn="shapefiles/mfws_nvis_vegetation_groups.shp") %>%
  spTransform(CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")) 
nvis_shp$area <- raster::area(nvis_shp)/1000000 #library(raster) in km2

# Calculate area per habitat type
mfws_group <- as.data.frame(nvis_shp) %>% 
  clean_names() %>%
  mutate(mfws_habitat=mfws_name) %>%
  group_by(mfws_habitat) %>%
  summarise(area_km2=sum(area))

# Assign MFWS minus aquatic area value
mfws_area_minus_aquatic <- sum(mfws_group$area_km2)-mfws_group$area_km2[1]

# Extract habitat type for each den coordinate and calculate frequencies
den_hab_adj <- den_nvis %>%
  group_by(mfws_habitat) %>% 
  count() %>% 
  # Adjusted by frequency of dens
  mutate(den_freq=n) %>%
  select(-n) %>%
  mutate(den_perc=(den_freq/sum(den_adj$den_freq))*100) %>%
  # Remove dens outside MFWS
  filter(!is.na(mfws_habitat))

# Adjust frequencies and percentages to account for habitat availability
den_hab_plot <- den_hab_adj %>%
  # Join with df to get area_km2 column
  left_join(mfws_group, by="mfws_habitat") %>%
  # Calculate frequency of dens adjusted by available area 
  mutate(den_freq_adj=((den_freq/area_km2)*
                         mfws_area_minus_aquatic/nrow(den_adj))) %>%
  # Calculate percentage of dens adjusted by available area
  mutate(den_perc_adj=(den_freq_adj/sum(den_plot$den_freq_adj))*100, 
         mfws_habitat=factor(mfws_habitat, 
                             levels = c("Grassland",
                                        "Eucalypt forest",
                                        "Eucalypt woodland",
                                        "Regrowth",
                                        "Aquatic")))

den_hab_plot <- den_hab_adj %>%
  # Join with df to get area_km2 column
  left_join(mfws_group, by="mfws_habitat") %>%
  # Calculate frequency of dens adjusted by available area 
  mutate(den_freq_adj=((den_freq/area_km2)*
                          mfws_area_minus_aquatic/nrow(den_adj))) %>%
  # Calculate percentage of dens adjusted by available area
  mutate(den_perc_adj=(den_freq_adj/sum(den_freq_adj))*100) %>%
  # Reorder levels of mfws_habitat
  mutate(mfws_habitat=factor(mfws_habitat, 
                               levels=c("Grassland",
                                          "Eucalypt forest",
                                          "Eucalypt woodland",
                                          "Regrowth",
                                          "Aquatic")))
# Reorder levels of mfws_habitat
den_plot$mfws_habitat <- factor(den_plot$mfws_habitat, 
                                 levels = c("Grassland", "Eucalypt forest", "Eucalypt woodland", "Regrowth", "Aquatic"))

# Display chi-square test results
den_nvis %>%
  # Remove any dens that were in habitat NA (i.e., outside MFWS)
  filter(!is.na(mfws_habitat)) %>%
  freq_table(mfws_habitat) %>%
  mutate(n=den_hab_plot$den_freq_adj, 
         percent=den_hab_plot$den_perc_adj) %>%
  freq_test() %>%
  # Select the statistics we're interested in
  select(mfws_habitat=cat, n, percent, t_crit, 
         chi2_pearson, df, p=p_chi2_pearson)
```

Bar plot

```{r}
# Plot raw den percentages per habitat type
hab_raw_barplot <- ggplot(data=den_plot, 
  aes(x= mfws_habitat, y=den_perc, fill=mfws_habitat)) + 
  geom_col() +
  annotate("text", x=4.4, y=60, label = parse(text = "bold('a')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"),
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 60), breaks=seq(0, 60, 10))

# Display the plot
print(hab_raw_barplot)

# Plot adjusted den percentages per habitat type
hab_adj_barplot <- ggplot(data=den_plot, 
  aes(x= mfws_habitat, y=den_perc_adj, fill=mfws_habitat)) +
  geom_col() +
  annotate("text", x=4.4, y=60, label = parse(text = "bold('b')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"),
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Percentage adjusted for availability (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0) +
  scale_y_continuous(limits=c(0, 60), breaks=seq(0, 60, 10)) 

# Display the plot
print(hab_adj_barplot)

# Combine the plots
hab_barplots <- ggarrange(hab_raw_barplot, hab_adj_barplot, ncol= 2, nrow= 1, 
                                   widths= c(1,1), heights = c(1,1)) %>%
  annotate_figure(bottom=text_grob("Habitat type", hjust=0.5, vjust=0))


# Display the combined plot
print(hab_barplots)
```

```{r, eval=FALSE, include=FALSE}
ggsave(hab_barplots, 
       filename="figures/habitat type barplots.jpeg", 
       width=225, height=100, units="mm")
```

## Activity 

  a) Plots

```{r}
# Transfer from wide to long format, and calculate percent for each level
long <- data %>%
  group_by(activity) %>%
  summarise(percent = 100/nrow(plot_data)*length(activity), 
            n = length(activity)) %>%
    na.omit() %>%
  mutate(activity = factor(activity, levels=c("Active", "Inactive", "Cannot find")))

# Create histogram plot
activity_hist <- ggplot(long, aes(x= activity, y=percent, fill=activity)) +
  geom_col() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"),
        axis.line.y = element_line(colour="grey")) +
  xlab("Activity") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0.7) +
  scale_y_continuous(limits=c(0, 100), breaks=seq(0, 100, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Histogram for publication
activity_hist_pub <- ggplot(long, aes(x= activity, y=percent, fill=activity)) +
  geom_col() +
  annotate("text", x=3.5, y=80, label = parse(text = "bold('e')"), size=5) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(), 
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"),
        axis.line.y = element_line(colour="grey")) +
  xlab("Activity") + ylab("Percentage (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=1, end=0.7) +
  scale_y_continuous(limits=c(0, 80), breaks=seq(0, 80, 10)) +
  geom_text(aes(label=paste("n = ", n), vjust=-0.5))

# Display the plot
print(activity_hist_pub)

# Subset to those records with valid activity types
plot_data <- subset(data, activity!="NA")

# Create map plot
activity_map <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat, group=group), 
            col="grey15") +
  geom_point(plot_data, mapping=aes(x=easting, y=northing, 
                                    col=activity), alpha=0.8) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.70, 0.25),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"),
        legend.key = element_blank()) +
  scale_colour_manual(values=viridis(length(unique(data$activity)), 
                                     begin=1, end=0), name="Den activity",
                      breaks=c('Active', 'Inactive', 'Cannot find')) +
  xlab("") + ylab("")

# Combine histogram and map into single plot
activity_plots <- ggarrange(activity_hist, activity_map, 
                            ncol=2, nrow=1, widths=c(3,3))
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(activity_plots, 
       filename="figures/den activity histogram and map.jpeg", 
       width=200, height=75, units="mm")

# Export the plot to a jpeg file
ggsave(activity_hist_pub, 
       filename="figures/activity histogram publication.jpeg", 
       width=150, height=75, units="mm")
```

  b) Models
  
```{r}
# Chi-square test
activity_mod <- data %>%
  subset(activity!="Cannot find") %>%
  freq_table(activity) %>%
  freq_test() %>%
  select(c(1:3, 5, 7, 12:14))
```

## Summary plot for publication

```{r}
summary_plot_dens <- ggarrange(den_type_hist_pub, 
                  den_substrate_hist_pub + rremove("ylab"),
                  hjust=-44, vjust=2,
                  ncol=2, nrow=1, widths=c(1,1))

print(summary_plot_dens)
summary_plot_den2 <- ggarrange(den_cover_hist_pub, 
                  hjust=-100, vjust=2, ncol=1, nrow=1, widths=c(1)) 

summary_plot_den3 <- ggarrange(entrances_hist_pub,activity_hist_pub + 
                               rremove("ylab"), 
                               hjust=-60, vjust=2, ncol=2, nrow=1, 
                               widths=c(1,1), heights = 2)

den_summary_plot <- ggarrange(summary_plot_dens,summary_plot_den2,
                               summary_plot_den3,ncol= 1, nrow= 3, 
                               widths= c(2,0.5,1), heights = c(2.5,3,2))
print(den_summary_plot)

```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(summary_plot_dens, filename="figures/summary plot dens.jpeg", 
       width=275, height=225, units="mm")

ggsave(summary_plot_den3, filename="figures/summary plot dens3.jpeg", 
       width=275, height=225, units="mm")

ggsave(den_summary_plot, filename="figures/den summary plot.jpeg", 
       width=275, height=260, units="mm")
```

# **Extrinsic den covariates**

We also quantified eastern quoll habitat use using the following rasters:

*Note for each whether they were from LiDAR, hyperspectral, or other sources*

1.  [Overstory layer cover fraction (LCF_OS)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/TERN/lidar/ACT/25m/LCF_OS/catalog.html),
2.  [Understory layer cover fraction (LCF_US)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/TERN/lidar/ACT/25m/LCF_US/catalog.html), and
3.  [Elevation (from DEM)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/TERN/lidar/ACT/25m/DEM/catalog.html?dataset=ub8-au/TERN/lidar/ACT/25m/DEM/DEM_ACT_mosaic.nc).
4.   [Derived aspect (from DEM)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/TERN/lidar/ACT/25m/DEM/catalog.html).
5. [Derived slope (from DEM)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/TERN/lidar/ACT/25m/DEM/catalog.html?dataset=ub8-au/TERN/lidar/ACT/25m/DEM/DEM_ACT_mosaic.nc).
6. [Topographic roughness (from DEM)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/TERN/lidar/ACT/25m/DEM/catalog.html?dataset=ub8-au/TERN/lidar/ACT/25m/DEM/DEM_ACT_mosaic.nc).
7.  [Vegetation Height (VH)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/TERN/lidar/ACT/25m/VH/catalog.html?dataset=ub8-au/TERN/lidar/ACT/25m/VH/VH_ACT_mosaic.nc)
8.  [Woody aboveground biomass density (WAGB)](https://dapds00.nci.org.au/thredds/catalog/ub8/au/LandCover/DEA_ALC/15_-40/catalog.html?dataset=ub8-au/LandCover/DEA_ALC/15_-40/VegHAGB_15_-40.nc).
9. [Soil: Clay, silt, and sand content, and depth of regolith](https://esoil.io/TERNLandscapes/Public/Pages/SLGA/ProductDetails-SoilAttributes.html#FileNamingConventions). 

## Digital elevation model (DEM)

```{r}
# Use raster package only to read in netcdf file
dem <- raster::raster("rasters/DEM_ACT_mosaic.nc") %>%
  t() %>% 
  flip(direction = 'x') %>% 
  terra::rast()

# Assign a projection for the raster
crs(dem) <- "EPSG:4326"  

# Transforming the projection from lat/long to easting/northing
dem <- project(dem, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
dem_mfws <- mask(dem, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(dem_mfws)

# Give the raster a name
names(dem_mfws) <- "Digital_Elevation_Model"

# Save as a tif file 
writeRaster(dem_mfws, "rasters/mfws_dem.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Convert and project coordinates as spatial points using sp
data_sp <- SpatialPointsDataFrame(
    data.frame(data$easting, data$northing), data,
    proj4string=CRS("EPSG:32755")) %>%
  st_as_sf()

# Extract raster values for each den coordinate
den_raster_values8 <- data_sp %>%
  mutate(elevation=raster::extract(dem_mfws, data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type="Dens", 
         raster="Elevation", 
         raster_units= elevation$Digital_Elevation_Model) %>%
  select(type, raster, raster_units) %>%
  na.omit(elevation)

# Extract available aspects in MFWS
avail_raster_values8 <- as.data.frame(rasterToPoints(mask(raster(dem_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Elevation", 
                raster_units = Digital_Elevation_Model) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values8 <- rbind(avail_raster_values8, den_raster_values8) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values8))
```

### Boxplot 

Boxplot comparing the extracted raster values for each den, and available across MFWS.

```{r}
# Create boxplot
elevation_boxplot <- ggplot(data=raster_values8, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha= 0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Elevation (m)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1)+
  scale_colour_viridis(discrete=T, option="D", begin=0.7,end=0.4) +
  scale_y_continuous(limits=c(620, 700), breaks=seq(620, 700, 10))

# Display the plot
print(elevation_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(elevation_boxplot, filename="figures/elevation boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read it back in
dem_map <- raster::raster("rasters/mfws_dem.tif")
dem_spdf <- as.data.frame(as(dem_map, "SpatialPixelsDataFrame"))
colnames(dem_spdf) <- c("value", "x", "y")

dem_map <- ggplot() + 
  geom_tile(data=dem_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name="Elevation (m)", breaks = c(620, 630, 640, 
                                                      650, 660, 670, 
                                                      680, 690, 700))

# Display the DEM map
print(dem_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(dem_map, filename="figures/elevation map.jpeg", 
       width=125, height=75, units="mm")
```

## Aspect

Derived from the DEM.

```{r}
# Derive aspect from the DEM
aspect_act <- terrain(dem, v="aspect")

# Display the raster
plot(aspect_act)

# Crop DEM by MFWS fence
aspect_mfws <- mask(aspect_act, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

plot(aspect_mfws)

# Give the raster a name
names(aspect_mfws) <- "Aspect"

# Save as a tif file
writeRaster(aspect_mfws, "rasters/mfws_aspect.tif", overwrite=TRUE)

# Save as a jpeg file
jpeg(file="rasters/mfws_aspect.jpeg", height=400, width=600)
  plot(aspect_mfws)
dev.off()
```

### Extract den and available values

```{r}
# Convert and project coordinates as spatial points using sp
data_sp <- SpatialPointsDataFrame(
    data.frame(data$easting, data$northing), data,
    proj4string=CRS("EPSG:32755")) %>%
  st_as_sf()

# Extract raster values for each den coordinate
den_raster_values <- data_sp %>%
  mutate(aspect=raster::extract(aspect_mfws, data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Aspect", 
         raster_units = aspect$Aspect) %>%
  select(type, raster, raster_units) %>%
  na.omit(aspect)

# Extract available aspects in MFWS
avail_raster_values <- as.data.frame(rasterToPoints(mask(raster(aspect_mfws), 
                                                         mf_fence))) %>%
  mutate(type = "Available", 
         raster = "Aspect", 
         raster_units = Aspect) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values <- rbind(avail_raster_values, den_raster_values) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

We note here that 209 aspect values were returned (i.e., 230 total minus 7 outside MFWS, where 14 not located in the field).

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values))
```

### Boxplot

Boxplot comparing the extracted raster values for each den, and available across MFWS.

```{r}
# Create boxplot
aspect_boxplot <- ggplot(data=raster_values, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha= 0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Aspect (°)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  #scale_colour_viridis(discrete=T, option="D", begin=0.7, end=0.4)
  scale_y_continuous(limits=c(0, 360), breaks=seq(0, 360, 30))

# Display the plot
print(aspect_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(aspect_boxplot, filename="figures/aspect boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
as_map <- raster::raster("rasters/mfws_aspect.tif")
as_spdf <- as.data.frame(as(as_map, "SpatialPixelsDataFrame"))
colnames(as_spdf) <- c("value", "x", "y")

as_map <- ggplot() + 
  geom_tile(data=as_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name="Aspect (°)", breaks = c(50, 100, 150, 
                                                   200, 250, 300, 
                                                   350, 400))
# Display the plot
print(as_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(as_map, filename="figures/aspect map.jpeg", 
       width=125, height=75, units="mm")
```

## Slope

Derived from the DEM.

```{r, eval=FALSE}
# Derive slope from the DEM
slope_act <- terrain(dem, v="slope")

# Display the raster
plot(slope_act)

# Crop DEM by MFWS fence
slope_mfws <- mask(slope_act, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the plot
plot(slope_mfws)

# Give the raster a name
names(slope_mfws) <- "Slope"

# Save as a tif file
writeRaster(slope_mfws, "rasters/mfws_slope.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Extract raster values for each den coordinate
den_raster_values1 <- data_sp %>%
  mutate(slope=raster::extract(slope_mfws, data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Slope", 
         raster_units = slope$Slope) %>%
  select(type, raster, raster_units) %>%
  na.omit(slope)

# Extract available slopes in MFWS
avail_raster_values1 <- as.data.frame(rasterToPoints(mask(raster(slope_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Slope", 
                raster_units = Slope) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values1 <- rbind(avail_raster_values1, den_raster_values1) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values1))
```

### Boxplot

Boxplot the extracted raster values for each den, and available slopes across MFWS.

```{r}
# Create a boxplot
slope_boxplot <- ggplot(data=raster_values1, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha= 0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Slope (°)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  scale_y_continuous(limits=c(0, 16), breaks=seq(0, 16, 2))

# Display the plot
print(slope_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(slope_boxplot, filename="figures/slope boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read it back in
slp_map <- raster::raster("rasters/mfws_slope.tif")
slp_spdf <- as.data.frame(as(slp_map, "SpatialPixelsDataFrame"))
colnames(slp_spdf) <- c("value", "x", "y")

slp_map <- ggplot() + 
  geom_tile(data=slp_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Slope (°)", breaks = c(0,2, 4, 6, 8, 10, 12, 14))

# Display the plot
print(slp_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(slp_map, filename="figures/slope map.jpeg", 
       width=125, height=75, units="mm")
```

## Topographic roughness (derived from DEM)

Topographic roughness represents the difference between the maximum and the minimum value of a cell and its eight surrounding cells.

```{r}
# Derive topographic roughness from the DEM
roughness_act <- terrain(dem, v="roughness")

# Display the raster
plot(roughness_act)

# Crop DEM by MFWS fence
roughness_mfws <- mask(roughness_act, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(roughness_mfws)

# Give the raster a name
names(roughness_mfws) <- "Roughness"

 # Save as a tif file
writeRaster(roughness_mfws, "rasters/mfws_roughness.tif", overwrite=TRUE)
```

```{r, eval=FALSE}
# Save as a jpeg file
jpeg(file="rasters/mfws_roughness.jpeg", height=400, width=600)
  plot(aspect_mfws)
dev.off()
```

### Extract den and available values

```{r}
# Convert and project coordinates as spatial points using sp
data_sp <- SpatialPointsDataFrame(
    data.frame(data$easting, data$northing), data,
    proj4string=CRS("EPSG:32755")) %>%
  st_as_sf()

# Extract raster values for each den coordinate
den_raster_values6 <- data_sp %>%
  mutate(roughness=raster::extract(roughness_mfws, data_sp, 
                                   method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type="Dens", raster="Roughness", 
         raster_units=roughness$Roughness) %>%
  select(type, raster, raster_units) %>%
  na.omit(roughness)

# Extract available aspects in MFWS
avail_raster_values6 <- as.data.frame(rasterToPoints(mask(raster(roughness_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Roughness", 
                raster_units = Roughness) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values6 <- rbind(avail_raster_values6, den_raster_values6) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values6))
```

### Boxplot

```{r}
# Create a boxplot
roughness_boxplot <- ggplot(data=raster_values6, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha= 0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Topographic roughness (m)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) + 
  #scale_colour_viridis(discrete=T, option="D", begin=0.7, end=0.4)
  scale_y_continuous(limits=c(0, 16), breaks=seq(0, 16, 2))

# Display the plot
print(roughness_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(roughness_boxplot, filename="figures/roughness boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
rough_map <- raster::raster("rasters/mfws_roughness.tif")
rough_spdf <- as.data.frame(as(rough_map, "SpatialPixelsDataFrame"))
colnames(rough_spdf) <- c("value", "x", "y")

# Display the plot
plot(rough_map)

# Create a map
rough_map <- ggplot() + 
  geom_tile(data=rough_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        legend.position = c(1.2, 0.5),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(t=-0.5, r=-1, b=-1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") + 
  guides(color=guide_legend(override.aes=list(fill=NA))) +
  scale_fill_viridis(name= "Topographic\n roughness (m)", breaks = c(0, 2, 4, 
                                                                     6, 8, 10, 
                                                                     12, 14, 16))

# Display the plot
print(rough_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(rough_map, filename="figures/roughness map.jpeg", 
       width=150, height=75, units="mm")
```

## Overstory

```{r}
# Use raster package only to read in netcdf file
overstory <- raster::raster("rasters/LCF_OS_ACT_mosaic.nc") %>%
  t() %>% 
  flip(direction = 'x') %>% 
  terra::rast()

# Assign a projection for the raster
crs(overstory) <- "EPSG:4326"

# Transforming the projection from lat/long to easting/northing
overstory <- project(overstory, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
overstory_mfws <- mask(overstory, mf_fence) %>%
  raster::crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(overstory_mfws)

# Give the raster a name
names(overstory_mfws) <- "Overstory"

# Save as a tif file 
writeRaster(overstory_mfws, "rasters/mfws_overstory.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Extract raster values for each den coordinate
den_raster_values2 <- data_sp %>%
  mutate(elevation=raster::extract(overstory_mfws, data_sp, 
                                   method="simple"),
         overstory=raster::extract(overstory_mfws, data_sp, 
                                   method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Overstory", 
         raster_units = overstory$Overstory*100) %>%
  select(type, raster, raster_units) %>%
  na.omit(overstory)

# Extract available overstory in MFWS
avail_raster_values2 <- as.data.frame(rasterToPoints(mask(raster(overstory_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Overstory", 
                raster_units = as.numeric(Overstory*100)) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values2 <- rbind(avail_raster_values2, den_raster_values2) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values2))
```

### Boxplot

Boxplot comparing extracted raster values for each den, and available overstory across MFWS.

```{r}
# Create a boxplot
overstory_boxplot <- ggplot(data=raster_values2, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Overstory (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  #scale_colour_viridis(discrete=T, option="D", begin=0.7, end=0.4) +
  scale_y_continuous(limits=c(0, 50), breaks=seq(0, 50, 5))

# Display the plot
print(overstory_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(overstory_boxplot, filename="figures/overstory boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read it back in
os_map <- raster::raster("rasters/mfws_overstory.tif")
os_spdf <- as.data.frame(as(os_map, "SpatialPixelsDataFrame"))
colnames(os_spdf) <- c("value", "x", "y")

# Create a map
os_map <- ggplot() + 
  geom_tile(data=os_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Overstory (%)")

# Display the map
print(os_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the map to a jpeg file
ggsave(os_map, filename="figures/overstory map.jpeg", 
       width=125, height=75, units="mm")
```

## Understory

```{r}
# Use raster package only to read in netcdf file
understory <- raster::raster("rasters/LCF_US_ACT_mosaic.nc") %>%
  t() %>% 
  flip(direction = 'x') %>% 
  terra::rast()

# Assign a projection for the raster
crs(understory) <- "EPSG:4326"

# Transforming the projection from lat/long to easting/northing
understory <- project(understory, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
understory_mfws <- mask(understory, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(understory_mfws)

# Give the raster a name
names(understory_mfws) <- "Understory"

# Save as a tif file 
writeRaster(understory_mfws, "rasters/mfws_understory.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Extract raster values for each den coordinate
den_raster_values3 <- data_sp %>%
  mutate(elevation=raster::extract(understory_mfws, 
                                   data_sp, method="simple"),
         understory=raster::extract(understory_mfws, 
                                    data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Understory", 
         raster_units = understory$Understory*100) %>%
  select(type, raster, raster_units) %>%
  na.omit(understory)

# Extract available understory in MFWS
avail_raster_values3 <- as.data.frame(rasterToPoints(mask(raster(understory_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Understory", 
                raster_units = Understory*100) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values3 <- rbind(avail_raster_values3, den_raster_values3) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values3))
```

### Boxplot

Boxplot comparing the extracted understory raster values for each den, and available understory across MFWS.

```{r}
# Create a boxplot
understory_boxplot <- ggplot(data=raster_values3, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Understory (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  scale_y_continuous(limits=c(0, 10), breaks=seq(0, 10, 1))

# Display the plot
print(understory_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(understory_boxplot, filename="figures/understory boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
us_map <- raster::raster("rasters/mfws_understory.tif")
us_spdf <- as.data.frame(as(us_map, "SpatialPixelsDataFrame"))
colnames(us_spdf) <- c("value", "x", "y")

us_map <- ggplot() + 
  geom_tile(data=us_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Understory (%)")

# Display the plot
print(us_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(us_map, filename="figures/understory map.jpeg", 
       width=125, height=75, units="mm")
```

## Vegetation height

```{r}
# Use raster package only to read in netcdf file
veg_height <- raster::raster("rasters/VH_ACT_mosaic.nc") %>%
  t() %>% 
  flip(direction = 'x') %>% 
  terra::rast()

# Assign a projection for the raster
crs(veg_height) <- "EPSG:4326"

# Transforming the projection from lat/long to easting/northing
veg_height <- project(veg_height, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
veg_height_mfws <- mask(veg_height, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(veg_height_mfws)

# Give the raster a name
names(veg_height_mfws) <- "Vegetation_Height"

# Save as a tif file 
writeRaster(veg_height_mfws, "rasters/mfws_veg_height.tif", overwrite=TRUE)
```

### Extracting den and available vegetation height

```{r}
# Extract raster values for each den coordinate
den_raster_values4 <- data_sp %>%
  mutate(elevation=raster::extract(veg_height_mfws, 
                                   data_sp, method="simple"),
         veg_height=raster::extract(veg_height_mfws, 
                                    data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type="Dens", raster="Vegetation height", 
         raster_units=veg_height$Vegetation_Height) %>%
  select(type, raster, raster_units) %>%
  na.omit(veg_height)

# Extract available vegetation height in MFWS
avail_raster_values4 <- as.data.frame(rasterToPoints(mask(raster(veg_height_mfws),
         mf_fence))) %>%
         mutate(type="Available", 
                raster="Vegetation height", 
                raster_units=as.numeric(Vegetation_Height)) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values4 <- rbind(avail_raster_values4, den_raster_values4) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")), 
         raster_units)
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, 
            family=gaussian, data=raster_values4))
```

### Boxplot

Boxplot comparing the extracted raster values for each den, and available vegetation height across MFWS.

```{r}
# Create a boxplot
veg_height_boxplot <- ggplot(data=raster_values4, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Vegetation height (m)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  scale_y_continuous(breaks=seq(0, 12, 1))
  
# Display the plot
print(veg_height_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(veg_height_boxplot, filename="figures/vegetation height boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
vght_map <- raster::raster("rasters/mfws_veg_height.tif")
vght_spdf <- as.data.frame(as(vght_map, "SpatialPixelsDataFrame"))
colnames(vght_spdf) <- c("value", "x", "y")

vght_map <- ggplot() + 
  geom_tile(data=vght_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Vegetation height (m)", breaks = c(2,4,6,8,10,12))

# Display the plot
print(vght_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(vght_map, filename="figures/vegetation height map.jpeg", 
       width=125, height=75, units="mm")
```

## Woody live aboveground biomass (WAGB) density

[WAGB](https://dapds00.nci.org.au/thredds/catalog/ub8/au/LandCover/DEA_ALC/15_-40/catalog.html?dataset=ub8-au/LandCover/DEA_ALC/15_-40/VegHAGB_15_-40.nc)

```{r, eval=FALSE}
# Use raster package only to read in netcdf file
wagb_raw <- raster::raster("C:/Users/kmacp/OneDrive/Documents/Masters/Research Year/WAGB/WAGB.nc", varname="WAGB") %>%
  t() %>% 
  flip(direction = 'x') %>% 
  terra::rast()

# Check projection of the raster
crs(wagb_raw)

# Transform projection from lat/long to easting/northing
wagb <- project(wagb_raw, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
wagb_mfws <- mask(wagb, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(wagb_mfws)

# Give the raster a name
names(wagb_mfws) <- "Woody_aboveground_biomass"

# Save as a tif file 
writeRaster(wagb_mfws, "rasters/mfws_wagb.tif", overwrite=TRUE)
```

### Extracting den and available WAGB

```{r}
# Extract raster values for each den coordinate
den_raster_values5 <- data_sp %>%
  mutate(wagb=raster::extract(wagb_mfws, 
                                    data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type="Dens", raster="Woody Aboveground Biomass", 
  raster_units=(wagb$Woody_aboveground_biomass)) %>%
  select(type, raster, raster_units) %>%
  na.omit(wagb)

# Extract available WAGB in MFWS
avail_raster_values5 <- as.data.frame(rasterToPoints(mask(raster(wagb_mfws), 
         mf_fence))) %>%
         mutate(type="Available", 
                raster="Woody Aboveground Biomass", 
                raster_units=(Woody_aboveground_biomass)) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values5 <- rbind(avail_raster_values5, den_raster_values5) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values5))
```

### Boxplot

Boxplot comparing the extracted raster values for each den, and available vegetation height across MFWS.

```{r}
# Create a boxplot
wagb_boxplot <- ggplot(data=raster_values5, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Woody aboveground biomass\n (tonnes/ha)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  scale_y_continuous(limits= c(0, 5), breaks=seq(0, 5, 0.5))
  
# Display the plot
print(wagb_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(wagb_boxplot, filename="figures/wagb boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Customise the raster layer

```{r}
# Read the raster back in
wagb_map <- raster::raster("rasters/mfws_wagb.tif")
wagb_spdf <- as.data.frame(as(wagb_map, "SpatialPixelsDataFrame"))
colnames(wagb_spdf) <- c("value", "x", "y")

# Create a map
wagb_map <- ggplot() + 
  geom_tile(data=wagb_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Woody aboveground\n biomass (tonnes/ha)")

# Display the plot
print(wagb_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(wagb_map, filename="figures/wagb map.jpeg", 
       width=125, height=75, units="mm")
```

## Soil

Here we use `get_soils_data()` from the `slga` package to obtain National Soil Attribute Maps (`NAT`) for our study site. 

These maps are combinations of the (1) Australia-wide 3D Soil Attribute Maps derived using consistent data mining-kriging models and (2) Regional Maps for parts of Australia, derived using disaggregation and data mining modeling. See [Google Earth Engine Data Catalog](https://developers.google.com/earth-engine/datasets/catalog/CSIRO_SLGA) for more information.

**Attributes:** `CLY` (clay), `SLT` (silt), `SND` (sand), `DER` (depth of regolith), `DES` (depth of soil).

**Components:** `VAL` (predicted value surface), `CLO` (lower 95% confidence interval surface), `CHI` (upper 95% confidence interval surface), `CIS` (both confidence interval surfaces), `ALL` (value and both confidence interval surfaces).

### Clay

```{r}
# Define area of interest
aoi <- c(149.1478, -35.18205, 149.187, -35.15579)

# Get soil rasters
clay <- slga::get_soils_data(product='NAT', 
                                 attribute='CLY',
                                 component='VAL', depth=1,
                                 aoi=aoi, write_out=FALSE) %>%
  rast()

# Assign a projection for the raster
crs(clay) <- "EPSG:4326"

# Transforming the projection from lat/long to easting/northing
clay <- project(clay, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
clay_mfws <- mask(clay, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(clay_mfws)

# Give the raster a name
names(clay_mfws) <- "Clay"

# Save as a tif file 
writeRaster(clay_mfws, "rasters/mfws_clay.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Extract raster values for each den coordinate
den_raster_values7 <- data_sp %>%
  mutate(clay=raster::extract(clay_mfws, data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Clay", 
         raster_units = clay$Clay) %>%
  select(type, raster, raster_units) %>%
  na.omit(clay)

# Extract available clay content in MFWS
avail_raster_values7 <- as.data.frame(rasterToPoints(mask(raster(clay_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Clay", 
                raster_units = as.numeric(Clay)) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values7 <- rbind(avail_raster_values7, den_raster_values7) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r, eval=FALSE}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values7))
```

### Boxplot

Boxplot comparing the extracted clay raster values for each den, and available clay content across MFWS.

```{r, eval= FALSE}
# Create a boxplot
clay_boxplot <- ggplot(data=raster_values7, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Clay content (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  scale_y_continuous(limits=c(10, 20), breaks=seq(10, 20, 1))

# Display the plot
print(clay_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(clay_boxplot, filename="figures/clay boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
cly_map <- raster::raster("rasters/mfws_clay_resample.tif")
cly_spdf <- as.data.frame(as(cly_map, "SpatialPixelsDataFrame"))
colnames(cly_spdf) <- c("value", "x", "y")

# Create a map
cly_map <- ggplot() + 
  geom_tile(data=cly_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Clay content (%)")

# Display the map
print(cly_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(cly_map, filename="figures/clay map.jpeg", 
       width=125, height=75, units="mm")
```

## Silt

```{r}
# Define area of interest
aoi <- c(149.1478, -35.18205, 149.187, -35.15579)

# Get soil rasters
silt <- slga::get_soils_data(product='NAT', 
                                 attribute='SLT',
                                 component='VAL', depth=1,
                                 aoi=aoi, write_out=FALSE) %>%
  rast()

# Assign a projection for the raster
crs(silt) <- "EPSG:4326"

# Transforming the projection from lat/long to easting/northing
silt <- project(silt, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
silt_mfws <- mask(silt, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(silt_mfws)

# Give the raster a name
names(silt_mfws) <- "Silt"

# Save as a tif file 
writeRaster(silt_mfws, "rasters/mfws_silt.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Extract raster values for each den coordinate
den_raster_values9 <- data_sp %>%
  mutate(silt=raster::extract(silt_mfws, data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Silt", 
         raster_units = silt$Silt) %>%
  select(type, raster, raster_units) %>%
  na.omit(silt)

# Extract available silt content in MFWS
avail_raster_values9 <- as.data.frame(rasterToPoints(mask(raster(silt_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Silt", 
                raster_units = Silt) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values9 <- rbind(avail_raster_values9, den_raster_values9) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values9))
```

### Boxplot

Boxplot comparing the extracted silt raster values for each den, and available clay content across MFWS.

```{r}
# Create a boxplot
silt_boxplot <- ggplot(data=raster_values9, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Silt content (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  scale_y_continuous(limits=c(14, 20), breaks=seq(14, 20, 1))

# Display the plot
print(silt_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(silt_boxplot, filename="figures/silt boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
slt_map <- raster::raster("rasters/mfws_silt_resample.tif")
slt_spdf <- as.data.frame(as(slt_map, "SpatialPixelsDataFrame"))
colnames(slt_spdf) <- c("value", "x", "y")

# Create a map
slt_map <- ggplot() + 
  geom_tile(data=slt_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Silt content (%)", breaks = c(14,15,16,17,18,19,
                                                          20))
# Display the plot
print(slt_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(slt_map, filename="figures/silt map.jpeg", 
       width=125, height=75, units="mm")
```

## Sand

```{r}
# Define area of interest
aoi <- c(149.1478, -35.18205, 149.187, -35.15579)

# Get soil rasters
sand <- slga::get_soils_data(product='NAT', 
                                 attribute='SND',
                                 component='VAL', depth=1,
                                 aoi=aoi, write_out=FALSE) %>%
  rast()

# Assign a projection for the raster
crs(sand) <- "EPSG:4326"

# Transforming the projection from lat/long to easting/northing
sand <- project(sand, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
sand_mfws <- mask(sand, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(sand_mfws)

# Give the raster a name
names(sand_mfws) <- "Sand"

# Save as a tif file 
writeRaster(sand_mfws, "rasters/mfws_sand.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Extract raster values for each den coordinate
den_raster_values10 <- data_sp %>%
  mutate(sand=raster::extract(sand_mfws, data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Sand", 
         raster_units = sand$Sand) %>%
  select(type, raster, raster_units) %>%
  na.omit(sand)

# Extract available silt content in MFWS
avail_raster_values10 <- as.data.frame(rasterToPoints(mask(raster(sand_mfws), 
         mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Sand", 
                raster_units = Sand) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values10 <- rbind(avail_raster_values10, den_raster_values10) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r, eval=FALSE}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values10))
```

### Boxplot

Boxplot comparing the extracted sand raster values for each den, and available sand content across MFWS.

```{r, eval=FALSE}
# Create a boxplot
sand_boxplot <- ggplot(data=raster_values10, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Sand content (%)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1) +
  scale_y_continuous(limits=c(54, 70), breaks=seq(54, 70, 2))

# Display the plot
print(sand_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(sand_boxplot, filename="figures/sand boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
snd_map <- raster::raster("rasters/mfws_sand_resample.tif")
snd_spdf <- as.data.frame(as(snd_map, "SpatialPixelsDataFrame"))
colnames(snd_spdf) <- c("value", "x", "y")

# Create a map
snd_map <- ggplot() + 
  geom_tile(data=snd_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Sand content (%)",breaks =c(56,58,60,62,
                                                        64,66,68))
# Display the plot
print(snd_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(snd_map, filename="figures/sand map.jpeg", 
       width=125, height=75, units="mm")
```

## Depth of regolith

```{r}
# Define area of interest
aoi <- c(149.1478, -35.18205, 149.187, -35.15579)

# Get soil rasters
regolith <- slga::get_soils_data(product='NAT', 
                                 attribute='DER',
                                 component='VAL', depth=1,
                                 aoi=aoi, write_out=FALSE) %>%
  rast()

# Assign a projection for the raster
crs(regolith) <- "EPSG:4326"

# Transforming the projection from lat/long to easting/northing
regolith <- project(regolith, "EPSG:32755")

# Read in MFWS fence polygon using sf
mf_fence <- st_read("shapefiles/mfws_fence.shp", quiet=TRUE) %>%
  st_set_crs("EPSG:32755")

# Crop DEM by MFWS fence
regolith_mfws <- mask(regolith, mf_fence) %>%
  crop(mf_fence, snap="near", mask=TRUE, touches=TRUE)

# Display the raster
plot(regolith_mfws)

# Give the raster a name
names(regolith_mfws) <- "Depth_of_regolith"

# Save as a tif file 
writeRaster(regolith_mfws, "rasters/mfws_regolith.tif", overwrite=TRUE)
```

### Extract den and available values

```{r}
# Extract raster values for each den coordinate
den_raster_values11 <- data_sp %>%
  mutate(regolith=raster::extract(regolith_mfws, data_sp, method="simple")) %>%
  st_drop_geometry() %>%
  mutate(type = "Dens", 
         raster = "Depth of regolith", 
         raster_units = regolith$NAT_DER_VAL_000_005) %>%
  select(type, raster, raster_units) %>%
  na.omit(regolith)

# Extract available regolith in MFWS
avail_raster_values11 <- as.data.frame(rasterToPoints(mask(raster(regolith_mfws), 
                                                           mf_fence))) %>%
         mutate(type = "Available", 
                raster = "Regolith", 
                raster_units = NAT_DER_VAL_000_005) %>%
  dplyr::select(type, raster, raster_units)

# Combine den and available raster values into single df
raster_values11 <- rbind(avail_raster_values11, den_raster_values11) %>%
  dplyr::select(type, raster, raster_units) %>%
  # Change the order of variables
  mutate(type = factor(type, levels=c("Dens", "Available")))
```

### Modelling

```{r}
# Run a generalised linear model
summary(glm(raster_units ~ type, family=gaussian, data=raster_values11))
```

### Boxplot

Boxplot comparing the extracted depth of regolith raster values for each den, and available depth of regolith across MFWS.

```{r}
# Create the boxplot
regolith_boxplot <- ggplot(data=raster_values11, 
                         aes(x=type, y=raster_units, fill=type)) +
  geom_boxplot(alpha=0.8) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        legend.position = "none", 
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  xlab("") + ylab("Depth of regolith (m)") +
  scale_fill_viridis(discrete=T, option="D", begin=0.8, end=0.1)+
  scale_y_continuous(limits=c(0, 18), breaks=seq(0, 18, 2))

# Display the plot
print(regolith_boxplot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(regolith_boxplot, filename="figures/depth of regolith boxplot.jpeg", 
       width=150, height=75, units="mm")
```

### Map

```{r}
# Read the raster back in
reg_map <- raster::raster("rasters/mfws_regolith_resample.tif")
reg_spdf <- as.data.frame(as(reg_map, "SpatialPixelsDataFrame"))
colnames(reg_spdf) <- c("value", "x", "y")

# Create a map
reg_map <- ggplot() + 
  geom_tile(data=reg_spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1.1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name= "Depth of regolith (m)",breaks=c(2,4,6,8,
                                                            10,12,14,16))

# Display the plot
print(reg_map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(reg_map, filename="figures/depth of regolith map.jpeg", 
       width=125, height=75, units="mm")
```

## Combine plots

```{r}
summary_plot <- ggarrange(elevation_boxplot, aspect_boxplot, slope_boxplot, 
                          roughness_boxplot, overstory_boxplot, 
                          understory_boxplot, veg_height_boxplot, 
                          wagb_boxplot, clay_boxplot, silt_boxplot, 
                          sand_boxplot, regolith_boxplot, ncol=3, nrow=4, 
                          widths=c(1,1,1,1,1,1))

# Display the combined plot
print(summary_plot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(summary_plot, filename="figures/raster boxplots.jpeg", 
       width=225, height=250, units="mm")
```

## Resample rasters

All raster layers need to have the same spatial extent and resolution before they can be input into an SDM. Since the soil rasters are at a different resolution to the rest, we need to `disaggregate()` and `resample` these to match the other environmental covariates.

```{r}
# Clay
clay_mfws_25m <- disagg(clay_mfws, fact=4, method="bilinear")
plot(clay_mfws_25m)
clay_resample <- resample(clay_mfws_25m, overstory_mfws)
plot(clay_resample)
writeRaster(clay_resample, "rasters/mfws_clay_resample.tif", overwrite=TRUE)

# Silt
silt_mfws_25m <- disagg(silt_mfws, fact=3, method="bilinear")
plot(silt_mfws_25m)
silt_resample <- resample(silt_mfws_25m, overstory_mfws)
writeRaster(silt_resample, "rasters/mfws_silt_resample.tif", overwrite=TRUE)

# Sand
sand_mfws_25m <- disagg(sand_mfws, fact=3, method="bilinear")
plot(sand_mfws_25m)
sand_resample <- resample(sand_mfws_25m, overstory_mfws)
writeRaster(sand_resample, "rasters/mfws_sand_resample.tif", overwrite=TRUE)

# Depth of regolith
regolith_mfws_25m <- disagg(regolith_mfws, fact=3, method="bilinear")
plot(regolith_mfws_25m)
regolith_resample <- resample(regolith_mfws_25m, overstory_mfws)
writeRaster(regolith_resample, "rasters/mfws_regolith_resample.tif", overwrite=TRUE)

# Woody aboveground biomass
wagb_resample <- resample(wagb_mfws, overstory_mfws)
writeRaster(wagb_resample, "rasters/mfws_wagb_resample.tif", overwrite=TRUE)
```

# **Species distribution models (SDMs)**

Our approach was to build several SDMs using different subsets of den sites based on ecologically relevant questions, then compare their performance:

  1. **Base model:** incorporates all den sites. 
  2. **Longevity model:**  incorporates den sites that were `active` when assessed in 2023.
  3. **Female model:** incorporates den sites used by females.
  4. **Visitation model:** incorporates den sites that were visted more than once across all radiotracking years (2016–2018).
  5. **Den sharing model:** incorporates den sites within which den sharing took place between multiple individuals, as detected through radiotracking.

First, we need to install the MaxEnt program, which only needs to be done once.

```{r, eval=FALSE}
# Install MaxEnt using java through the dismo package 
utils::download.file(url = "https://raw.githubusercontent.com/mrmaxent/Maxent/master/ArchivedReleases/3.3.3k/maxent.jar", destfile = paste0(system.file("java", package = "dismo"), "/maxent.jar"), mode = "wb") 
```

## Base model

```{r, eval=FALSE}
# Check if Maxent is correctly installed
checkMaxentInstallation()

# Read in den data and extract den coordinates
den_xy <- data %>%
  select(x = easting, y = northing) %>%
  as.data.frame()

# Read in MFWS fence polygon using sf
mf_fence <- vect("shapefiles/mfws_fence.shp")

# Generate random points throughout MFWS extent
set.seed(28)
random_xy <- data.frame(cbind(x = runif(500, 695623.361478806, 
                                        699148.364320755),
                              y = runif(500, 6104653.07377434, 
                                        6107482.9784832))) %>%
                                        as.data.frame()
```

Run a correlation matrix to check for similarity between covariates.

```{r}
# Create a SWD object using generated background points
bg <- prepareSWD(species = "Dasyurus viverrinus", 
                 a = random_xy, 
                 env = predictors)

# Plot a correlation matrix heat map with the value of the correlation coefficients
plotCor(bg, method = "spearman", cor_th = 0.7)
```

Here we select our environmental covariates (i.e., predictors).

```{r}
# Read in predictor variables
covariate_files <- list.files("rasters", full.names = TRUE, pattern="*.tif")

# Select predictor variables
covariate_files <- covariate_files[c(1,2,3,5,6,8,9,10,11)] 

# Stack the rasters
predictors <- rast(covariate_files)
```

We now use [SDMtune](website) to generate a 'samples with data' (SWD) object.

```{r}
# Prepare the data into the correct format using SWD (samples with data)
swd <- SDMtune::prepareSWD(species = "Dasyurus viverrinus",
                           p = den_xy, #presence points
                           a = random_xy, #background points
                           env = predictors,
                           verbose = TRUE)

# View the created SWD object
swd

# Visualise the data
head(swd@data)

# Visualise the coordinates
head(swd@coords)

# Print the name of species
swd@species
```

### Model training

```{r}
# Use function train() to train a MaxEnt model
default_model <- train(method = "Maxent", data = swd, fc = "lq")

# Output of train() is an object of class SDMmodel(), explore a SDMmodel object
print(default_model)

# A SDMmodel has two objects
slotNames(default_model)

# The slot model contains the configurations of the model plus other information used to make predictions
slotNames(default_model@model)

# Make predictions
pred <- predict(default_model, data = swd, type = "cloglog")

# The output is a vector containing all the predicted values for the training locations
head(pred)

# Create a distribution map
map <- predict(default_model, data=predictors, type="cloglog")

# Customise colour of map
viridisLite::viridis(n=5)

# Plot the distribution map
plotPred(map, lt = "Habitat suitability",
         colorramp = c("#440154FF", "#3B528BFF", "#21908CFF", 
                       "#5DC863FF", "#FDE725FF"))
```

### Model evaluation

```{r}
# Calculate the AUC (Area Under Curve)
auc(default_model)

# Plot the ROC curve (Receiver Operating Characteristic)
plotROC(default_model)

# Calculate the AICc
aicc(default_model, 
     env = predictors)

# Evaluate variable importance
vi <- maxentVarImp(default_model)

# Explore percent contribution and permutation importance
print(vi)

# Plot response curves of the covariates
plotResponse(default_model, 
             var = "Aspect", 
             type = "cloglog", 
             only_presence = TRUE, 
             marginal = FALSE, 
             rug = TRUE)
```

### Model training and testing

It’s always a good practice to split the species locations into two parts and use one part to train the model and the remaining part to evaluate it. When we have to deal with a small dataset a better approach is cross validation. 

```{r}
# Create the folds. The output of the function is a list containing two matrices, the first for the training and the second for the testing locations.
folds <- randomFolds(swd, k = 4, only_presence = TRUE, seed = 25)

# Perform a 4 fold cross validation using the Maxent method
cv_model <- train("Maxent", data = swd, folds = folds)

# Compute the AUC of the model
auc(cv_model)
auc(cv_model, test = TRUE)

# Run a Jackknife test to estimate the variable importance. The test removes one variable at time and records the change in the chosen metric (AUC). 
jk <- doJk(cv_model, metric = "auc", test = test)
```

*Plot random points*

```{r, eval=FALSE}
# Read in shapefile as df for plotting
mfws <- readOGR(dsn="shapefiles/mfws_fence.shp", verbose=FALSE) %>%
  spTransform(CRS("+proj=utm +zone=55 +datum=WGS84")) %>%
  fortify(verbose=FALSE) %>% #transforms from from sp to df
  mutate(lat=as.numeric(lat + 10000000), 
         long=as.numeric(long))

# Create a map
plot_xy <- ggplot() + 
  geom_path(mfws, mapping=aes(x=long, y=lat), col="grey15") +
  geom_spatraster(data = veg_height) +
  geom_spatvector(data = random_xy, col="yellow") +
  geom_point(den_xy, mapping=aes(x=x, y=y), col="green", alpha=0.5) +
  geom_path(mfws, mapping=aes(x=long, y=lat), col="grey15") +
  #geom_point(random_xy, mapping=aes(x=x, y=y), alpha=0.5) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(0.70, 0.20),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.key = element_blank()) +
  #scale_colour_manual(values=viridis(length(unique()), begin=0.2, end=0.9)) +
  xlab("") + ylab("")

# Display the plot
print(plot_xy)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(plot_xy, filename="figures/dens, random points, and raster map.jpeg", 
       width=200, height=125, units="mm")
```

## Longevity model

### Data preparation

```{r}
# Read in den data and extract den coordinates
active_xy <- data %>%
  subset(activity== "Active") %>%
  select(x = easting, y = northing) %>%
  as.data.frame() 
```

### SDM

```{r}
# Read in predictor variables
covariate_files <- list.files("rasters", full.names = TRUE, pattern="*.tif")

# Select predictor variables
covariate_files <- covariate_files[c(1,2,3,5,6,9,10,11)] 

# Stack the rasters
predictors <- rast(covariate_files)

# Prepare the data into the correct format using SWD (samples with data)
swd <- SDMtune::prepareSWD(species = "Dasyurus viverrinus",
                           p = active_xy, #presence points
                           a = random_xy, #background points
                           env = predictors,
                           verbose = TRUE)

# Use function train() to train a MaxEnt model
default_model <- train(method = "Maxent", data = swd, fc = "lq")

# Make predictions
pred <- predict(default_model, data = swd, type = "cloglog")

# The output is a vector containing all the predicted values for the training locations
head(pred)
```

### Map

```{r}
# Create a distribution map
map <- predict(default_model, data=predictors, type="cloglog")

# Plot the distribution map
plotPred(map, lt = "Habitat suitability",
         colorramp = c("#440154FF", "#3B528BFF", "#21908CFF", 
                       "#5DC863FF", "#FDE725FF"))

# Save output map as a tif file 
writeRaster(map, "output/map.tif", overwrite=TRUE)

# Read the raster back in
sdm_map <- raster::raster("output/map.tif")
spdf <- as.data.frame(as(sdm_map, "SpatialPixelsDataFrame"))
colnames(spdf) <- c("value", "x", "y")

# Create a map
map <- ggplot() + 
  geom_tile(data=spdf, mapping=aes(x, y, fill=value)) +
  annotation_scale(style="ticks", tick_height=0.5, width_hint=0.3,
                   pad_x=unit(5, "cm"), pad_y=unit(2.5, "cm")) +
  coord_sf(xlim=c(695750, 699250), ylim=c(6104250, 6107750)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_rect(fill="white"),
        legend.position = c(1.1, 0.55),
        legend.title = element_text(size=9), 
        legend.text = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        legend.key.height = unit(1, 'cm'),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-0.5, -1, -1, -1), "cm"), 
        legend.spacing.y = unit(0.5, "cm")) +
  xlab("") + ylab("") +
  scale_fill_viridis(name="Habitat\nsuitability")

# Display the plot
print(map)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(map, filename="figures/sdm map.jpeg", 
       width=150, height=75, units="mm")
```

### Model evaluation

```{r}
# Calculate the AUC (Area Under Curve)
auc(default_model)

# Calculate the AICc
aicc(default_model, env = predictors)

# Evaluate variable importance
vi <- maxentVarImp(default_model)

# Explore percent contribution and permutation importance
print(vi)
write.csv(vi, "output/variable importance.csv")

# Create the folds. The output of the function is a list containing two matrices, the first for the training and the second for the testing locations.
folds <- randomFolds(swd, k = 4, only_presence = TRUE, seed = 25)

# Perform a 4 fold cross validation using the Maxent method
cv_model <- train("Maxent", data = swd, folds = folds)

# Compute the AUC of the model
auc(cv_model)
auc(cv_model, test = TRUE)

# Run a Jackknife test to estimate the variable importance. The test removes one variable at time and records the change in the chosen metric (AUC). 
jk <- doJk(cv_model, metric = "auc", test = test)
```

### Response curves
 
```{r}
# Overstory
os_response <- plotResponse(default_model, var = "Overstory", type = "cloglog", 
                            only_presence = TRUE, marginal = FALSE, rug = TRUE)

os_curve <- ggplot2::ggplot_build(os_response)$data[[1]] %>%
  mutate(var = "Overstory (%)", x = x*100)

# Understory
us_response <- plotResponse(default_model, var = "Understory", type = "cloglog", 
                            only_presence = TRUE, marginal = FALSE, rug = TRUE)

us_curve <- ggplot2::ggplot_build(us_response)$data[[1]] %>%
  mutate(var = "Understory (%)", x = x*100)

# Aspect
as_response <- plotResponse(default_model, var = "Aspect", type = "cloglog", 
                            only_presence = TRUE, marginal = FALSE, rug = TRUE)

as_curve <- ggplot2::ggplot_build(as_response)$data[[1]] %>%
  mutate(var = "Aspect (°)")

# Clay
cly_response <- plotResponse(default_model, var = "Clay", 
                             type = "cloglog", only_presence = TRUE, 
                             marginal = FALSE, rug = TRUE)

cly_curve <- ggplot2::ggplot_build(cly_response)$data[[1]] %>%
  mutate(var = "Clay content (%)") 
        
# Silt
slt_response <- plotResponse(default_model, var = "Silt", 
                             type = "cloglog", only_presence = TRUE, 
                             marginal = FALSE, rug = TRUE)

slt_curve <- ggplot2::ggplot_build(slt_response)$data[[1]] %>%
  mutate(var = "Silt content (%)") 

# Depth of regolith
reg_response <- plotResponse(default_model, var = "Depth_of_regolith", 
                             type = "cloglog", only_presence = TRUE, 
                             marginal = FALSE, rug = TRUE)

reg_curve <- ggplot2::ggplot_build(reg_response)$data[[1]] %>%
  mutate(var = "Depth of regolith (m)") 

# Slope
slp_response <- plotResponse(default_model, var = "Slope", 
                             type = "cloglog", only_presence = TRUE, 
                             marginal = FALSE, rug = TRUE)

slp_curve <- ggplot2::ggplot_build(slp_response)$data[[1]] %>%
  mutate(var = "Slope (°)")

# Digital Elevation Model
dem_response <- plotResponse(default_model, 
                         var = "Digital_Elevation_Model", 
                         type = "cloglog", 
                         only_presence = TRUE, 
                         marginal = FALSE, 
                         rug = TRUE)

dem_curve <- ggplot2::ggplot_build(dem_response)$data[[1]] %>%
  mutate(var = "Elevation (m)")

# Combine and reorder variable curves
curves <- rbind(os_curve, as_curve, cly_curve, slt_curve, reg_curve,
                slp_curve, dem_curve, us_curve) %>%
  select(x, y, var) %>%
  mutate(var=factor(var, levels=c("Elevation (m)", "Aspect (°)", "Slope (°)", 
                                  "Overstory (%)", "Understory (%)", 
                                  "Clay content (%)", 
                                  "Silt content (%)",
                                  "Depth of regolith (m)")))

# Plot all curves  
resp_curves_plot <- ggplot(curves, mapping=aes(x, y)) +
  geom_smooth(aes(col=var, fill=var)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        panel.border = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none", 
        strip.background = element_rect(fill="#363842"),
        strip.text = element_text(colour="white"),
        axis.line.x = element_line(colour="grey"), 
        axis.line.y = element_line(colour="grey")) +
  facet_wrap(~var, scales="free", ncol=2) +
  xlab("") + ylab("Cloglog output") +
  scale_colour_viridis_d() +
  scale_fill_viridis_d()

# Display the plot
print(resp_curves_plot)
```

```{r, echo=FALSE, eval=FALSE}
# Export the plot to a jpeg file
ggsave(resp_curves_plot, filename="figures/response curves.jpeg", 
       width=175, height=200, units="mm")
```

## Female model

### Data preparation

```{r}
# Read in sexes data
sexes <- read_excel(raw_data, sheet="visits") %>%
  clean_names() %>%
  select(den_id=eqd_code, quoll_code, sex) %>%
  group_by(den_id, sex) %>%
  summarise(f_visits=length(quoll_code)) %>%
  subset(sex=="F") %>%
  select(-sex) %>%
  left_join(data, by="den_id") %>%
  filter(f_visits!="NA")

# Extract coordinates for SDM
sexes_xy <- sexes %>%
  ungroup() %>%
  select(x = easting, y = northing) %>%
  as.data.frame() %>%
  na.omit()
```

### SDM

```{r}
# Prepare the data into the correct format using SWD (samples with data)
swd <- SDMtune::prepareSWD(species = "Dasyurus viverrinus",
                           p = sexes_xy, #presence points
                           a = random_xy, #background points
                           env = predictors,
                           verbose = TRUE)

# Use function train() to train a MaxEnt model
default_model <- train(method = "Maxent", data = swd, fc = "lq")

# Make predictions
pred <- predict(default_model, data = swd, type = "cloglog")

# The output is a vector containing all the predicted values for the training locations
head(pred)

# Create a distribution map
map <- predict(default_model, data=predictors, type="cloglog")

# Plot the distribution map
plotPred(map, lt = "Habitat\nsuitability",
         colorramp = c("#440154FF", "#3B528BFF", "#21908CFF", 
                       "#5DC863FF", "#FDE725FF"))

# Calculate the AUC (Area Under Curve)
auc(default_model)

# Calculate the AICc
aicc(default_model, env = predictors)
```

```{r}
# Evaluate variable importance
vi <- maxentVarImp(default_model)

# Explore percent contribution and permutation importance
print(vi)

# Create the folds. The output of the function is a list containing two matrices, the first for the training and the second for the testing locations.
folds <- randomFolds(swd, k = 4, only_presence = TRUE, seed = 25)

# Perform a 4 fold cross validation using the Maxent method
cv_model <- train("Maxent", data = swd, folds = folds)

# Compute the AUC of the model
auc(cv_model)
auc(cv_model, test = TRUE)

# Run a Jackknife test to estimate the variable importance. The test removes one variable at time and records the change in the chosen metric (AUC). 
jk <- doJk(cv_model, metric = "auc", test = test)

# Plot response curves of the covariates
plotResponse(default_model, var = "Aspect", type = "cloglog", 
             only_presence = TRUE, marginal = FALSE, rug = TRUE)
```

## Visitation model

### Data preparation

```{r}
# Read in data
visits <- read_excel(raw_data, sheet="visits") %>%
  clean_names() %>%
  select(den_id=eqd_code, quoll_code, sex) %>%
  group_by(den_id) %>%
  summarise(visits=length(quoll_code)) %>%
  subset(visits!=1) %>%
  left_join(data, by="den_id") %>%
  filter(visits!="NA")
  
# Extract coordinates for SDM
visits_xy <- visits %>%
  select(x = easting, y = northing) %>%
  as.data.frame()
```

### SDM

```{r}
# Prepare the data into the correct format using SWD (samples with data)
swd <- SDMtune::prepareSWD(species = "Dasyurus viverrinus",
                           p = visits_xy, #presence points
                           a = random_xy, #background points
                           env = predictors,
                           verbose = TRUE)

# Use function train() to train a MaxEnt model
default_model <- train(method = "Maxent", data = swd, fc = "lq")

# Make predictions
pred <- predict(default_model, data = swd, type = "cloglog")

# The output is a vector containing all the predicted values for the training locations
head(pred)

# Create a distribution map
map <- predict(default_model, data=predictors, type="cloglog")

# Plot the distribution map
plotPred(map, lt = "Habitat\nsuitability",
         colorramp = c("#440154FF", "#3B528BFF", "#21908CFF", 
                       "#5DC863FF", "#FDE725FF"))

# Calculate the AUC (Area Under Curve)
auc(default_model)

# Calculate the AICc
aicc(default_model, 
     env = predictors)
```

```{r}
# Evaluate variable importance
vi <- maxentVarImp(default_model)

# Explore percent contribution and permutation importance
print(vi)

# Create the folds. The output of the function is a list containing two matrices, the first for the training and the second for the testing locations.
folds <- randomFolds(swd, k = 4, only_presence = TRUE, seed = 25)

# Perform a 4 fold cross validation using the Maxent method
cv_model <- train("Maxent", data = swd, folds = folds)

# Compute the AUC of the model
auc(cv_model)
auc(cv_model, test = TRUE)

# Run a Jackknife test to estimate the variable importance. The test removes one variable at time and records the change in the chosen metric (AUC). 
jk <- doJk(cv_model, metric = "auc", test = test)

# Plot response curves of the covariates
plotResponse(default_model, var = "Aspect", type = "cloglog", 
             only_presence = TRUE, marginal = FALSE, rug = TRUE)
```

## Den sharing model

### Data preparation

```{r}
# Read in data
cohabit <- read_excel(raw_data, sheet="visits") %>%
  clean_names() %>%
  select(den_id=eqd_code, quoll_code, sex, date=date_tracked) %>%
  group_by(den_id, date) %>%
  summarise(concurrence=length(quoll_code)) %>%
  subset(concurrence!=1) %>%
  group_by(den_id) %>%
  summarise(max_concurrence=max(concurrence))

data_cohabit <- data %>%
  left_join(cohabit, by="den_id") %>%
  filter(max_concurrence!="NA")

#Too few (38) dens had cohabitating eastern quolls.
```

# **Session information**

```{r}
sessionInfo()
```